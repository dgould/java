/* SchemeInput.java1234567890123456789012345678901234567890123456789012345678901234567890123456789*/package jscm;import java.awt.*;import java.util.*;public class SchemeInteraction extends TextArea{//PUBLIC CLASS CONSTANTS	public static final String PROMPT = "\n> ";	//PRIVATE DATA MEMBERS	private int nextStart;	private SchemeInterpreter mInterpreter;	private Checkbox mDebug;//CONSTRUCTORS	public SchemeInteraction(int rows, int cols, Checkbox debug)	{		super(rows, cols);		mInterpreter = new SchemeInterpreter();		mDebug = debug;	}	public SchemeInteraction(int rows, int cols)	{		super(rows, cols);		mInterpreter = new SchemeInterpreter();		mDebug = null;	}	//PUBLIC INSTANCE METHODS	//print prompt	public void Prompt()	{		super.appendText(PROMPT);		nextStart = super.getText().length();	}		//read text starting after last prompt (at nextStart), eval, print	public void ReadEvalPrint()	{		int depth = ParenDepth();		int spaces, i;		if(depth == 0)		{			SchemeObject exp = mInterpreter.Read(super.getText(), nextStart);			if(mDebug != null && mDebug.getState())			{				//super.appendText(mInterpreter.Print(exp) + " ==> ");				mInterpreter.debug = true;			}			super.appendText(				mInterpreter.Print(					mInterpreter.Eval(exp, mInterpreter.globalEnv)));						Prompt();			nextStart = super.getText().length();		}		if(depth < 0)		{			//HUH? still need to handle this error		}		if(depth > 0) //print spaces to set tab		{			char text [] = super.getText().toCharArray();						int enclosingParen = HindDepth();			if(enclosingParen >= nextStart)			{				spaces = 0;				while(enclosingParen - spaces >= 0 &&				      text[enclosingParen - spaces] != '\n')				{					spaces++;				}								String s = "";				for(i = 0; i <= spaces; i++)				{					s += " ";				}				super.appendText(s);			}		}	}		public void Reset()	{		super.setText(PROMPT);		nextStart = super.getText().length();		//mInterpreter.Reset();		mInterpreter = new SchemeInterpreter();	}//PRIVATE INSTANCE METHODS	//return number of unmatched left parentheses starting at nextStart	private int ParenDepth()	{		char text [] = super.getText().toCharArray();		int depth = 0;		for(int i = nextStart; i < super.getText().length(); i++)		{			if(text[i] == '(')			{				depth++;			}			if(text[i] == ')')			{				depth--;			}		}		return depth;	}		//return index of last unmatched left parenthesis, i.e., start of	//enclosing expression	private int HindDepth()	{		char text [] = super.getText().toCharArray();		int depth = 0, i;		i = super.getText().length() - 1;		while(text[i] == '\n' || text[i] == ' ')		{			i--;		}		for(depth = 0; i >= 0 && depth >= 0; i--)		{			if(text[i] == '(')			{				depth--;			}			if(text[i] == ')')			{				depth++;			}		}				if(i + 1 < nextStart) //HUH?		{			return -1;		}				return i + 1;	}		public boolean keyUp(Event e, int key)	{		if(key == '\n' || key == '\r' || e.controlDown() || e.metaDown())		{			ReadEvalPrint();						return true;		}				return super.keyUp(e, key);	}		public boolean keyDown(Event e, int key)	{		//if key == delete && cursor at nextStart, return true				return super.keyDown(e, key);	}}